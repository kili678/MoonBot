import os
import discord
from discord.ext import commands
import requests
import asyncio

from flask import Flask

app = Flask(__name__)

@app.route('/')
def home():
    return "Bot is alive!"

def start():
    port = int(os.environ.get("PORT", 10000))  # Port impos√© par Render
    app.run(host="0.0.0.0", port=port)

intents = discord.Intents.default()
intents.message_content = True
intents = discord.Intents.all()
bot = commands.Bot(command_prefix='!', intents=intents)

PECHEURS_ROLE = "P√©cheurs"
PECHE_S_CAPITAUX = [
    "Luxure", "Col√®re", "Envie", "Paresse", "Orgueil", "Gourmandise", "Avarice"
]


def send_data_to_api(owner_name, players_dict):
    url = "https://siteapi-2.onrender.com/update"
    payload = {
        "owner": owner_name,
        "players": players_dict  # üëà On regroupe tout dans une cl√© "players"
    }
    try:
        response = requests.post(url, json=payload, timeout=10)
        if response.status_code == 200:
            print(f"[API] ‚úÖ Envoy√© : owner={owner_name}")
        else:
            print(f"[API] ‚ö†Ô∏è Code {response.status_code} : {response.text}")
    except requests.exceptions.Timeout:
        print(f"[API] ‚è±Ô∏è Timeout vers l'API")
    except requests.exceptions.ConnectionError:
        print(f"[API] üîå Erreur de connexion vers l'API")
    except Exception as e:
        print(f"[API] ‚ùå Erreur lors de l'envoi : {e}")


async def periodic_task():
    await bot.wait_until_ready()
    print("[Bot] T√¢che p√©riodique d√©marr√©e")

    while not bot.is_closed():
        try:
            # V√©rifier que le bot est toujours connect√©
            if not bot.is_ready():
                print("[Bot] Bot non pr√™t, attente...")
                await asyncio.sleep(10)
                continue

            # V√©rifier qu'il y a au moins un serveur
            if not bot.guilds:
                print("[Bot] Aucun serveur trouv√©, attente...")
                await asyncio.sleep(30)
                continue

            app_info = await bot.application_info()
            owner_name = app_info.owner.name

            guild = bot.guilds[0]
            role_pecheurs = discord.utils.get(guild.roles, name=PECHEURS_ROLE)

            players = {}
            for peche in PECHE_S_CAPITAUX:
                role_peche = discord.utils.get(guild.roles, name=peche)
                if not role_peche:
                    players[peche] = {"name": "Place vacante", "avatar": None}
                    continue
                    
                joueur = None
                for member in guild.members:
                    if role_pecheurs in member.roles and role_peche in member.roles:
                        joueur = member
                        break
                        
                    if joueur:
                        players[peche] = {
                        "name": joueur.display_name,
                        "avatar": joueur.avatar.url if joueur.avatar else joueur.default_avatar.url
                    }
                else:
                    players[peche] = {"name": "Place vacante", "avatar": None}
            send_data_to_api(owner_name, players)
            print(
                f"[Bot] Donn√©es envoy√©es avec succ√®s - {len(players)} p√©ch√©s trait√©s"
            )

        except discord.errors.HTTPException as e:
            print(f"[Erreur Discord] HTTP : {e}")
            await asyncio.sleep(
                30)  # Attendre plus longtemps en cas d'erreur Discord
        except Exception as e:
            print(f"[Erreur] t√¢che p√©riodique : {e}")
            print(f"[Debug] Type d'erreur : {type(e).__name__}")

        await asyncio.sleep(60)

async def auto_bump():
    await bot.wait_until_ready()  # On attend que le bot soit pr√™t
    while not bot.is_closed():
        # R√©cup√®re le serveur et le salon "bot"
        for guild in bot.guilds:
            channel = discord.utils.get(guild.text_channels, name="„Äåü§ñ„Äçbot")
            if channel:
                try:
                    await channel.send("/bump")
                    print(f"[BUMP] /bump envoy√© dans {guild.name}")
                except Exception as e:
                    print(f"[BUMP] Erreur : {e}")
            else:
                print(f"[BUMP] Erreur :channel pas trouv√©")
        # Attend 2 heures et 10 minutes (2*3600 + 10*60 = 7800 secondes)
        await asyncio.sleep(7800)


@bot.event
async def on_ready():
    print(f"Bot connect√© en tant que {bot.user}")
    print(f"Connect√© √† {len(bot.guilds)} serveur(s)")
    bot.loop.create_task(periodic_task())
    bot.loop.create_task(auto_bump()) 
            
@bot.event
async def on_error(event, *args, **kwargs):
    print(f"[Erreur Bot] √âv√©nement {event} : {args}")


@bot.event
async def on_disconnect():
    print("[Bot] D√©connect√© de Discord")


@bot.event
async def on_resumed():
    print("[Bot] Reconnect√© √† Discord")
    
@bot.event
async def on_message(message):
    # Emp√™che le bot de r√©pondre √† lui-m√™me
    if message.author == bot.user:
        return

    if "bonjour" in message.content.lower():
        await message.channel.send(f"Bonjour {message.author} ! ü§ó")

    if "fafa" in message.content.lower():
        await message.add_reaction("üçÜ")  # Correction ici
        
    if "zeleph" in message.content.lower():
        await message.add_reaction("ü¶ä")  # Correction ici

    if "killian" in message.content.lower():
        await message.add_reaction("ü•µ")  # Correction ici

    if "nuggets" in message.content.lower():
        await message.add_reaction("üêî")  # Correction ici

    if "kuzoki" in message.content.lower():
        await message.add_reaction("üê∫")  # Correction ici

    if "noisette" in message.content.lower():
        await message.add_reaction("üå∞")  # Correction ici

    if "pigeon" in message.content.lower():
        await message.add_reaction("üê§")  # Correction ici

    if "piaf" in message.content.lower():
        await message.add_reaction("üê§")  # Correction ici
        
    if "sakir" in message.content.lower():
        await message.add_reaction("ü¶ù")
        
    # Si le bot est mentionn√©
    if bot.user in message.mentions:
        await message.channel.send(
            f"Oui {message.author.mention} ?"
        )

    # Permet au bot de traiter les commandes si besoin
    await bot.process_commands(message)
    
@bot.command(name="classement")
async def classement(ctx):
    guild = ctx.guild

    classement = []

    for peche in PECHE_S_CAPITAUX:
        role_peche = discord.utils.get(guild.roles, name=peche)
        if not role_peche:
            classement.append((peche, 0))
            continue

        count = len(role_peche.members)
        classement.append((peche, count))

    # Trie le classement par nombre d√©croissant
    classement.sort(key=lambda x: x[1], reverse=True)

    # Formatage du message
    msg = "**Classement des p√©ch√©s capitaux (par nombre de membres) :**\n"
    for i, (peche, count) in enumerate(classement, 1):
        msg += f"**{i}. {peche}** ‚Äî {count} membre(s)\n"

    await ctx.send(msg)      
    
@bot.command()
@commands.is_owner()  # seule la personne propri√©taire du bot peut utiliser
async def reload(ctx, extension: str = None):
    """Recharge une extension ou toutes"""
    if extension:
        try:
            await bot.reload_extension(f"cogs.{extension}")
            await ctx.send(f"‚úÖ Extension `{extension}` recharg√©e.")
        except Exception as e:
            await ctx.send(f"‚ùå Erreur en rechargant `{extension}`: `{e}`")
    else:
        reloaded = []
        for filename in os.listdir("./cogs"):
            if filename.endswith(".py"):
                try:
                    await bot.reload_extension(f"cogs.{filename[:-3]}")
                    reloaded.append(filename)
                except Exception as e:
                    await ctx.send(f"‚ùå Erreur dans `{filename}`: `{e}`")
        await ctx.send(f"‚úÖ Extensions recharg√©es : {', '.join(reloaded)}")

token = os.environ.get('TOKEN')
print("TOKEN charg√© ? ", 'TOKEN' in os.environ)
print("Longueur du token :", len(os.environ.get('TOKEN', '')))
if not token:
    print("Erreur : variable d'environnement TOKEN absente ou vide.")
    exit(1)
    
import threading
threading.Thread(target=start).start()

bot.run(token)










